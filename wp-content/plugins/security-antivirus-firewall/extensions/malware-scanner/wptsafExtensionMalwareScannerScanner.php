<?php
/*  
 * Security Antivirus Firewall (wpTools S.A.F.)
 * http://wptools.co/wordpress-security-antivirus-firewall
 * Version:           	2.1.23
 * Build:             	34569
 * Author:            	WpTools
 * Author URI:        	http://wptools.co
 * License:           	License: GNU/GPLv3 http://www.gnu.org/licenses/gpl-3.0.html
 * Date:              	Tue, 17 Jan 2017 18:05:12 GMT
 */

if ( ! defined( 'WPINC' ) )  die;
if ( ! defined( 'ABSPATH' ) ) exit;

class wptsafExtensionMalwareScannerScanner{

	
	const REQUEST_LIMIT_TIME_FRAME = 60; // sec
	const REQUEST_LIMIT_COUNT = 4;
	const REQUEST_LIMIT_FILE = 200;
	const REQUEST_LIMIT_SIZE = 32000000; // Mb
	const REQUEST_LIMIT_RESOURCES = 25; // Mb
	const PACKING_TIMEOUT = 600; // sec
	const DIR_TMP_CLEAN_FILE_AGE = 86400; // 1 day

	const FILE_STATUS_PENDING = 'pending';
	const FILE_STATUS_CHECKED = 'checked';
	const FILE_STATUS_PROBABLY_INFECTED = 'probably-infected';
	const FILE_STATUS_INFECTED = 'infected';
	const FILE_STATUS_NOT_EXISTS = 'not-exists';
	const FILE_STATUS_TOO_LARGE = 'too-large';

	const SCAN_MODE_ARCHIVE = 'archive';
	const SCAN_MODE_FILE = 'file';

	const SCAN_STATUS_PENDING = 'pending';
	const SCAN_STATUS_PACKING = 'packing';
	const SCAN_STATUS_SCANNING = 'scanning';
	const SCAN_STATUS_SCANNED = 'scanned';
	const SCAN_STATUS_PASS = 'pass';

	protected $extension;
	protected $api;
	protected $wpdb;
	protected $table;
	protected $dirTmp;
	protected $requestCount = 0;

	protected $optionRequestLastTime;

	function __construct(wptsafAbstractExtension $extension){
		global $wpdb;
		

		$this->extension = $extension;
		$this->api = new VirusTotalApi($this->extension->getSettings()->get('api_key'));
		$this->wpdb = $wpdb;
		$this->table = $this->extension->getLog()->getTable();
		$this->dirTmp = WPTSAF_DIR . $this->extension->getExtensionDir() . 'tmp/';

		$this->optionRequestLastTime = WPTSAF_OPTION_KEY_PREFIX . 'malware_scanner_request_last_time';
	}


	public function process(){
		$requestLastTime = get_site_option( $this->optionRequestLastTime );
		$now = wptsafEnv::getInstance()->getDateGmt();

		if ($requestLastTime && self::REQUEST_LIMIT_TIME_FRAME > $now - $requestLastTime) {
			return;
		}
		update_site_option( $this->optionRequestLastTime, $now);

		$this->fixBrokenPackingFiles();
		$this->cleanDirTmp();
		$this->updateScanResults();
		$this->scanProbablyInfectedFiles();
		$this->scanPendingFiles();
	}


	public function isNeedToProcess(){
		$needToProcess = $this->wpdb->get_var($this->wpdb->prepare(
			"SELECT count(*) FROM {$this->table} WHERE scan_status not in ('%s', '%s')",
			self::SCAN_STATUS_SCANNED,
			self::SCAN_STATUS_PASS
		));

		return 0 < $needToProcess;
	}

	public function fixBrokenPackingFiles(){
		$now = wptsafEnv::getInstance()->getDateGmt();
		$brokenFilesCount = $this->wpdb->query($this->wpdb->prepare(
			"UPDATE {$this->table}
			SET scan_status = '%s'
			WHERE scan_status = '%s' AND scan_date_gmt < '%d'",
			self::SCAN_STATUS_PENDING,
			self::SCAN_STATUS_PACKING,
			$now - self::PACKING_TIMEOUT
		));

		if ($brokenFilesCount) {
			wptsafExtensionSystemLog::getInstance()->getLog()->addWarningMessage(
				$this->extension,
				sprintf(__('Fixed %d broken packing file(s)', 'wptsaf_security'), $brokenFilesCount)
			);
		}
	}

	public function cleanDirTmp(){
		$cleanFileAge = wptsafEnv::getInstance()->getDateGmt() - self::DIR_TMP_CLEAN_FILE_AGE;
		$archives = glob("{$this->dirTmp}*.zip");

		foreach ($archives as $archive) {
			if (filemtime($archive) < $cleanFileAge) {
				unlink($archive);
			}
		}
	}


	protected function updateScanResults(){
		if (self::REQUEST_LIMIT_COUNT <= $this->requestCount) {
			return;
		}

		$scans = $this->wpdb->get_results($this->wpdb->prepare(
			"SELECT * FROM {$this->table}
			WHERE scan_resource IS NOT NULL AND scan_status = '%s'
			GROUP BY scan_resource
			LIMIT 0, %d",
			self::SCAN_STATUS_SCANNING,
			self::REQUEST_LIMIT_RESOURCES
		), ARRAY_A);
		$scanResources = array();

		foreach ($scans as $scan) {
			$scanResources[$scan['scan_resource']] = $scan;
		}
		if (!$scanResources) {
			return;
		}

		$reports = $this->api->fetchReports(array_keys($scanResources));
		if ($reports) {
			foreach ($reports as $report) {
				if (isset($report['response_code']) && 1 == $report['response_code']) {
					$resource = $report['resource'];
					$scan = $scanResources[$resource];
					$isSingleFile = self::SCAN_MODE_FILE == $scan['scan_mode'];
					$isInfected = ($report['positives'] > 0);
					$status = $isInfected
						? ($isSingleFile ? self::FILE_STATUS_INFECTED : self::FILE_STATUS_PROBABLY_INFECTED)
						: self::FILE_STATUS_CHECKED;
					$scanStatus = $isInfected && !$isSingleFile ? self::SCAN_STATUS_PENDING : self::SCAN_STATUS_SCANNED;

					$this->wpdb->query($this->wpdb->prepare(
						"UPDATE {$this->table}
						SET status = '%s', scan_status = '%s', scan_date_gmt = '%s'
						WHERE scan_resource = '%s'",
						$status,
						$scanStatus,
						wptsafEnv::getInstance()->getDateGmt(),
						$resource
					));

					if (self::FILE_STATUS_INFECTED == $status) {
						$this->notifyAdmin($resource);
					}
				}
			}
		}

		$error = $this->api->getError();
		$statusCode = $this->api->getStatusCode();
		if ($error || 200 != $statusCode) {
			wptsafExtensionSystemLog::getInstance()->getLog()->addDangerMessage(
				$this->extension,
				__('Error fetch reports', 'wptsaf_security')
				. "\n" . __('Status Code: ', 'wptsaf_security') . $statusCode
				. "\n"  . __('Error: ', 'wptsaf_security') . htmlentities($error)
			);
		}
		
		$this->requestCount++;
	}


	protected function scanProbablyInfectedFiles(){
		while (self::REQUEST_LIMIT_COUNT > $this->requestCount) {
			$resource = $this->wpdb->get_var($this->wpdb->prepare(
				"SELECT scan_resource FROM {$this->table}
				WHERE status = '%s' AND scan_status = '%s'
				LIMIT 0, 1",
				self::FILE_STATUS_PROBABLY_INFECTED,
				self::SCAN_STATUS_PENDING
			));
			if (!$resource) {
				break;
			}

			$packId = 'pack-' . md5(time() . mt_rand());
			$needToScan = $this->wpdb->get_var($this->wpdb->prepare(
				"SELECT count(*) count FROM {$this->table}
				WHERE status = '%s' AND scan_resource = '%s' AND scan_status = '%s'",
				self::FILE_STATUS_PROBABLY_INFECTED,
				$resource,
				self::SCAN_STATUS_PENDING
			));
			$allowRequests = self::REQUEST_LIMIT_COUNT - $this->requestCount;
			$packCount = 1 == $allowRequests ? 2 : $allowRequests;
			$limitFiles = min(ceil($needToScan / $packCount), self::REQUEST_LIMIT_FILE);

			$this->wpdb->query($this->wpdb->prepare(
				"UPDATE {$this->table}
				SET scan_resource = '%s', scan_mode = '%s', scan_status = '%s', scan_date_gmt = '%s'
				WHERE status = '%s' AND scan_resource = '%s' AND scan_status = '%s'
				LIMIT %d",
				$packId,
				1 == $limitFiles ? self::SCAN_MODE_FILE : self::SCAN_MODE_ARCHIVE,
				self::SCAN_STATUS_PACKING,
				wptsafEnv::getInstance()->getDateGmt(),
				self::FILE_STATUS_PROBABLY_INFECTED,
				$resource,
				self::SCAN_STATUS_PENDING,
				$limitFiles
			));
			$files = $this->wpdb->get_results($this->wpdb->prepare(
				"SELECT id, file FROM {$this->table}
				WHERE scan_resource = %s AND scan_status = '%s'",
				$packId,
				self::SCAN_STATUS_PACKING
			));

			if (1 == count($files)) {
				$this->sendFile($packId, $resource, reset($files));
			} else {
				$this->sendFiles($packId, $resource, $files);
			}
		}
	}


	protected function scanPendingFiles(){
		while (self::REQUEST_LIMIT_COUNT > $this->requestCount) {
			$needToScan = $this->wpdb->get_var($this->wpdb->prepare(
				"SELECT count(*) count FROM {$this->table}
				WHERE scan_status = '%s'",
				self::SCAN_STATUS_PENDING
			));
			if (!$needToScan) {
				break;
			}

			$packId = 'pack-' . md5(time() . mt_rand());
			$allowRequests = self::REQUEST_LIMIT_COUNT - $this->requestCount;
			$limitFiles = min(ceil($needToScan / $allowRequests), self::REQUEST_LIMIT_FILE);

			$this->wpdb->query($this->wpdb->prepare(
				"UPDATE {$this->table}
				SET scan_resource = '%s', scan_mode = '%s', scan_status = '%s', scan_date_gmt = '%s'
				WHERE scan_status = '%s'
				LIMIT %d",
				$packId,
				1 == $limitFiles ? self::SCAN_MODE_FILE : self::SCAN_MODE_ARCHIVE,
				self::SCAN_STATUS_PACKING,
				wptsafEnv::getInstance()->getDateGmt(),
				self::SCAN_STATUS_PENDING,
				$limitFiles
			));
			$files = $this->wpdb->get_results($this->wpdb->prepare(
				"SELECT id, file FROM {$this->table}
				WHERE scan_resource = %s AND scan_status = '%s'",
				$packId,
				self::SCAN_STATUS_PACKING
			));

			if (1 == count($files)) {
				$this->sendFile($packId, null, reset($files));
			} else {
				$this->sendFiles($packId, null, $files);
			}
		}
	}


	protected function sendFile($packId, $scanResource, $file){
		$absPath = rtrim(ABSPATH, DIRECTORY_SEPARATOR);
	
		try {
			$filePath = $absPath . $file->file;

			if (!file_exists($filePath)) {
				$this->wpdb->query($this->wpdb->prepare(
					"UPDATE {$this->table}
					SET status = '%s', scan_resource = NULL, scan_status = '%s'
					WHERE id = '%d'",
					self::FILE_STATUS_NOT_EXISTS,
					self::SCAN_STATUS_PASS,
					$file->id
				));
				return;
			}

			if (filesize($filePath) > self::REQUEST_LIMIT_SIZE) {
				$this->wpdb->query($this->wpdb->prepare(
					"UPDATE {$this->table}
					SET status = %s, scan_resource = NULL, scan_status = %s
					WHERE id = '%d'",
					self::FILE_STATUS_TOO_LARGE,
					self::SCAN_STATUS_PASS,
					$file->id
				));
				throw new Exception(sprintf(
					__('File is too large for scanning. File: %s', 'wptsaf_security'),
					$file->file
				));
			}

			$response = $this->api->uploadFile($filePath);
			if (isset($response['response_code']) && 1 == $response['response_code']) {
				$this->wpdb->query($this->wpdb->prepare(
					"UPDATE {$this->table}
					SET scan_resource = '%s', scan_status = '%s', scan_date_gmt = '%d'
					WHERE id = '%d'",
					$response['resource'],
					self::SCAN_STATUS_SCANNING,
					wptsafEnv::getInstance()->getDateGmt(),
					$file->id
				));
			} else {
				throw new Exception(
					__('Cannot upload file', 'wptsaf_security')
					. "\n" . __('Status Code: ', 'wptsaf_security') . $this->api->getStatusCode()
					. "\n" . __('Error: ', 'wptsaf_security')  . htmlentities($this->api->getError())
				);
			}
		} catch (Exception $e) {

			wptsafExtensionSystemLog::getInstance()->getLog()->addDangerMessage($this->extension, $e->getMessage());
		} 
		/* php version >= 5.5*/
		//finally {
			$setScanResource = $scanResource
				? $this->wpdb->prepare("scan_resource = '%s'", $scanResource)
				: 'scan_resource = NULL';
			$this->wpdb->query($this->wpdb->prepare(
				"UPDATE {$this->table}
				SET  {$setScanResource}, scan_mode = NULL, scan_status = '%s', scan_date_gmt = NULL
				WHERE scan_resource = '%s' AND scan_status = '%s'",
				self::SCAN_STATUS_PENDING,
				$packId,
				self::SCAN_STATUS_PACKING
			));

			$this->requestCount++;
		//}
	}


	protected function sendFiles($packId, $scanResource, array $files){
		$absPath = rtrim(ABSPATH, DIRECTORY_SEPARATOR);
		$fileIndex = 0;
		$filePackedIds = array();
		$fileNotExistsIds = array();
		$pack = new ZipArchive();
		$packPath = "{$this->dirTmp}{$packId}.zip";
		$packSize = 0;
		$packFilesNum = 0;

		try {
			$pack->open($packPath, ZipArchive::CREATE);
			for ($fileCount = count($files); $fileIndex < $fileCount; $fileIndex++) {
				$file = $files[$fileIndex];
				$filePath = $absPath . $file->file;

				if (!file_exists($filePath)) {
					$fileNotExistsIds[] = $file->id;
					continue;
				}

				$fileSize = filesize($filePath);

				if ($fileSize > self::REQUEST_LIMIT_SIZE) {
					$this->wpdb->query($this->wpdb->prepare(
						"UPDATE {$this->table}
						SET status = %s, scan_resource = NULL, scan_status = %s
						WHERE id = '%d'",
						self::FILE_STATUS_TOO_LARGE,
						self::SCAN_STATUS_PASS,
						$file->id
					));
					throw new Exception(sprintf(
						__('File is too large for scanning. File: %s', 'wptsaf_security'),
						$file->file
					));
				}

				if ($packSize + $fileSize > self::REQUEST_LIMIT_SIZE) {
					break;
				}

				$pack->addFile($filePath, $file->file);
				$packSize += strlen(gzcompress(file_get_contents($filePath)));
				$filePackedIds[] = $file->id;
			}
			$packFilesNum = $pack->numFiles;
			$pack->close();

			if ($fileNotExistsIds) {
				$this->wpdb->query($this->wpdb->prepare(
					"UPDATE {$this->table}
					SET status = '%s', scan_resource = NULL, scan_status = '%s'
					WHERE scan_resource = '%s' AND scan_status = '%s'",
					self::FILE_STATUS_NOT_EXISTS,
					self::SCAN_STATUS_PASS,
					$packId,
					self::SCAN_STATUS_PACKING
				));
			}

			if (0 != $packFilesNum) {
				if (!file_exists($packPath)) {
					throw new Exception(__('Cannot create pack', 'wptsaf_security'));
				}

				$response = $this->api->uploadFile($packPath);
				if (isset($response['response_code']) && 1 == $response['response_code']) {
					$this->wpdb->query($this->wpdb->prepare(
						"UPDATE {$this->table}
						SET scan_resource = '%s', scan_status = '%s', scan_date_gmt = '%d'
						WHERE scan_resource = '%s' AND scan_status = '%s'",
						$response['resource'],
						self::SCAN_STATUS_SCANNING,
						wptsafEnv::getInstance()->getDateGmt(),
						$packId,
						self::SCAN_STATUS_PACKING
					));
				} else {
					throw new Exception(
						__('Cannot upload pack', 'wptsaf_security')
						. "\n" . __('Status Code: ', 'wptsaf_security') . $this->api->getStatusCode()
						. "\n" . __('Error: ', 'wptsaf_security') . htmlentities($this->api->getError())
					);
				}
			}
		} catch (Exception $e) {
			wptsafExtensionSystemLog::getInstance()->getLog()->addDangerMessage($this->extension, $e->getMessage());
		} 
		/* php version >= 5.5*/
		//finally {
			$setScanResource = $scanResource
				? $this->wpdb->prepare("scan_resource = '%s'", $scanResource)
				: 'scan_resource = NULL';
			$this->wpdb->query($this->wpdb->prepare(
				"UPDATE {$this->table}
				SET  {$setScanResource}, scan_mode = NULL, scan_status = '%s', scan_date_gmt = NULL
				WHERE scan_resource = '%s' AND scan_status = '%s'",
				self::SCAN_STATUS_PENDING,
				$packId,
				self::SCAN_STATUS_PACKING
			));
			if (file_exists($packPath)) {
				unlink($packPath);
			}

			$this->requestCount++;
		//}
	}


	protected function notifyAdmin($resource){
		if (!$this->extension->getSettings()->get('is_notify_admin')) {
			return;
		}

		$view = new wptsafView();
		$files = $this->wpdb->get_results($this->wpdb->prepare(
			"SELECT * FROM {$this->table}
			WHERE scan_resource = '%s'",
			$resource
		));
		$emailContent = $view->content(
			$this->extension->getExtensionDir() . 'template/email/found-infected-files.php',
			array('files' => $files)
		);
		$recipients = wptsafSecurity::getInstance()->getSettings()->get('notification_emails');
		$blogName = get_bloginfo('name');

		foreach ($recipients as $recipient) {
			wp_mail(
				$recipient,
				"{$blogName}: " . $this->extension->getTitle(),
				$emailContent
			);
		}

	}
}
